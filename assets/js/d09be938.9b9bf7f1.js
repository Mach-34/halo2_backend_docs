"use strict";(self.webpackChunkhalo_2_backend_docs=self.webpackChunkhalo_2_backend_docs||[]).push([[105],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(n),m=r,h=u["".concat(l,".").concat(m)]||u[m]||d[m]||i;return n?a.createElement(h,o(o({ref:t},c),{},{components:n})):a.createElement(h,o({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2591:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const i={sidebar_position:3},o="ACIR OpCodes",s={unversionedId:"acir",id:"acir",title:"ACIR OpCodes",description:"The Aztec Noir DSL provides an intuitive, rust-like language that is saved to .nr files. Noir circuits are meant to emulate traditional code as closely as possible. Under the hood, however, .nr files are translated into an intermediate representation (IR) called the ACIR (abstract circuit intermediate representation). The IR provides all the necessary information to generate a constraint system in any language.",source:"@site/docs/3_acir.md",sourceDirName:".",slug:"/acir",permalink:"/halo2_backend_docs/acir",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"defaultSidebar",previous:{title:"Getting Started",permalink:"/halo2_backend_docs/getting_started"},next:{title:"ACVM Backends",permalink:"/halo2_backend_docs/acvm"}},l={},p=[{value:"Examining the ACIR",id:"examining-the-acir",level:2},{value:"OpCodes",id:"opcodes",level:2},{value:"Expressions",id:"expressions",level:3},{value:"Black Box Functions",id:"black-box-functions",level:3},{value:"Directives",id:"directives",level:3}],c={toc:p},u="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"acir-opcodes"},"ACIR OpCodes"),(0,r.kt)("p",null,"The Aztec Noir DSL provides an intuitive, rust-like language that is saved to ",(0,r.kt)("inlineCode",{parentName:"p"},".nr")," files. Noir circuits are meant to emulate traditional code as closely as possible. Under the hood, however, ",(0,r.kt)("inlineCode",{parentName:"p"},".nr")," files are translated into an intermediate representation (IR) called the ",(0,r.kt)("strong",{parentName:"p"},"ACIR")," (",(0,r.kt)("em",{parentName:"p"},"abstract circuit intermediate representation"),"). The IR provides all the necessary information to generate a constraint system in any language."),(0,r.kt)("h2",{id:"examining-the-acir"},"Examining the ACIR"),(0,r.kt)("p",null,'For the following demonstration, we will use the "hello world" circuit generated by running ',(0,r.kt)("inlineCode",{parentName:"p"},"nargo new hello_world"),". The easiest way to manually examine the ACIR is to run any nargo command with the acir print flag. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'# in the newly created "./hello_world" folder\nnargo compile --print-acir\n')),(0,r.kt)("p",null,"which outputs"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Compiled ACIR for main:\ncurrent witness index : 11\npublic parameters indices : []\nreturn value indices : []\nBLACKBOX::RANGE [(_1, num_bits: 32)] [ ]\nBLACKBOX::RANGE [(_2, num_bits: 32)] [ ]\nBLACKBOX::RANGE [(_3, num_bits: 32)] [ ]\nDIR::QUOTIENT (out : _%EXPR [ (1, _1) (-1, _2) 2\xb3\xb2 ]%,  (_5, %EXPR [ 2\xb3\xb2 ]%), _4)\nBLACKBOX::RANGE [(_4, num_bits: 32)] [ ]\nEXPR [ (1, _5, _5) (-1, _5) 0 ]\nEXPR [ (-1, _1) (1, _2) (1, _10) -2\xb3\xb2 ]\nEXPR [ (1, _4) (2\xb3\xb2, _5) (-1, _10) 0 ]\nEXPR [ (-1, _3) (1, _4) (-1, _6) 0 ]\nDIR::INVERT (_6, out: _7) \nEXPR [ (1, _6, _7) (-1, _8) 0 ]\nEXPR [ (1, _6, _8) (-1, _6) 0 ]\nEXPR [ (1, _8) 0 ]\n")),(0,r.kt)("h2",{id:"opcodes"},"OpCodes"),(0,r.kt)("p",null,"OpCodes are how we shape the constraint system. There are three main types of OpCodes present in the ACIR:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Expressions"),(0,r.kt)("li",{parentName:"ul"},"Black Box Functions"),(0,r.kt)("li",{parentName:"ul"},"Directives")),(0,r.kt)("p",null,"The values given for witnesses in the ACIR are indexes that can be used to look up and assign the true values later, when proofs are actually being made. Doing this allows us to shape a constraint system that is agnostic to the inputs. "),(0,r.kt)("h3",{id:"expressions"},"Expressions"),(0,r.kt)("p",null,"Expressions are simple, and the ACVM is capable of computing the expected values for witnesses. We simply need to assign these values inside the proof system's backend."),(0,r.kt)("p",null,"There are three types of terms in our expressions: ",(0,r.kt)("em",{parentName:"p"},"linear"),", ",(0,r.kt)("em",{parentName:"p"},"multiplicative"),", and ",(0,r.kt)("em",{parentName:"p"},"constant"),". Coefficients are printed only as numbers themselves (",(0,r.kt)("inlineCode",{parentName:"p"},"-1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"2\xb3\xb2"),', etc) while witnesses are prefixed with "_" (',(0,r.kt)("inlineCode",{parentName:"p"},"_4"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"_5"),", etc). "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Linear term (coefficient * variable): ",(0,r.kt)("inlineCode",{parentName:"li"},"(1, _4)"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"(2\xb3\xb2, _5)"),", etc"),(0,r.kt)("li",{parentName:"ul"},"Multiplicative term (coefficient ",(0,r.kt)("em",{parentName:"li"}," variable_a ")," variable_b): ",(0,r.kt)("inlineCode",{parentName:"li"},"(1, _6, _7)"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"(1, _6, _8)"),", etc"),(0,r.kt)("li",{parentName:"ul"},"Constant term: ",(0,r.kt)("inlineCode",{parentName:"li"},"0"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"_4"),", etc")),(0,r.kt)("p",null,"Say we want to prove ",(0,r.kt)("inlineCode",{parentName:"p"},"5x + 6y == 1"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"5x + 6y - 1 == 0"),". This expression becomes ",(0,r.kt)("inlineCode",{parentName:"p"},"EXPR [(5, _1), (6, _2) -1 ]"),"."),(0,r.kt)("p",null,"This explanation is paraphrased from ",(0,r.kt)("a",{parentName:"p",href:"https://discourse.aztec.network/u/kevaundray/summary"},"kevayndray"),", with ",(0,r.kt)("a",{parentName:"p",href:"https://discourse.aztec.network/t/acir-arithmetic-expressions-how-do-selectors-work/602/2"},"more detail and their loose connection to plonk arithmetization here"),"."),(0,r.kt)("h3",{id:"black-box-functions"},"Black Box Functions"),(0,r.kt)("p",null,"Black Box Functions are much more complex than expressions. Functionality like hashing, elliptic curve operations, and proof recursion will generally make use of efficiency optimizations in the underlying proving system (perhaps using custom gates or lookup arguments). "),(0,r.kt)("p",null,"Take ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/noir-lang/acvm/blob/060255aab09e3b04d181b41c48448db29fe6125b/acir/src/circuit/opcodes/black_box_function_call.rs#L34-L37"},(0,r.kt)("inlineCode",{parentName:"a"},"SHA256 black box opcode"))," (not yet implemented in Halo2 Backend):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"SHA256 {\n    inputs: Vec<FunctionInput>,\n    outputs: Vec<Witness>,\n},\n")),(0,r.kt)("p",null,"Here, the ACIR would provide an opcode that looks something like ",(0,r.kt)("inlineCode",{parentName:"p"},"BLACKBOX::SHA256 [(_1, num_bits: 8), (_2, num_bits: 8)] [ (_3,...,_34)]"),". Here, witness inputs and outputs are provided, and the ACVM backend is responsible for constraining the proper computation to reach the outputs from the inputs. Your backend will create further interstitial witness values inside the black box, however only the input and output of the black box function is tracked by the ACIR."),(0,r.kt)("h3",{id:"directives"},"Directives"),(0,r.kt)("p",null,"Directives are unconstrained operations that are handled by the ACVM witness generator. The witness map generated by the ACVM will handle directive opcodes for you."))}d.isMDXComponent=!0}}]);